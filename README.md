# flinkedlist

## flinkedlist, Fortran Linked List 

- flinkedlist is a pure Fortran library providing an  simple linked list.
- flinkedlist is OOP designed.
- flinkedlist has some useful features like below.
  - sort elements(which is called `node` in this library) by user defined function
  - apply user defined function in each `node`.
  - Includes a convenience method to aid printf debugging by automatically displaying variables of built-in types and providing a dedicated display function for user-defined types.
  - By using the `node_operator_type` type to manipulate list elements, users can use the list data type without worrying about the internal details of the type.
  - List elements can be converted to arrays of type `node_operator_array`, so you can choose an array-like access method for list elements.

## Build
This repository is built using [fpm](https://fpm.fortran-lang.org/en/index.html).
You can also use this library by compiling `flinkedlist.f90' with your main program source code, since it is no dependency other than fortran code.

If you use fpm, do the following.
```bash
pip install fpm
git clone https://github.com/sakamoti/flinkedlist.git
cd flinkedlist

# build and run test program
fpm test
```

To use `flinkedlist` within your fpm project, add the following to your `fpm.toml` file:
```bash
[dependencies]
flinkedlist = {git = "https://github.com/sakamoti/flinkedlist.git"}
```

## DOCUMENT (API)

If you don't have documentation tool, you should first install
[`ford`](https://forddocs.readthedocs.io/en/latest/index.html).
```bash
pip install ford
```
Then, auto generated documentation is available.
```bash
ford flinkedlist-doc-ford-settings.md
```

## USAGE
Please check `test/check.f90` or document generated by `ford`.

About `list_type`.
- `list_type` is a double linked list that can hold any data type.
- By declaring `type(list_type) :: list`, you can register data into the list one after another, such as `list%append("AnyType")`.
- `list%append` inserts data in the first element (it is called `head` in the source) of the list if the position of data insertion is not specified.
- The `node_operator_type` type is used for user access to the elements of the list.

About `node_operator_type`.
- The `node_operator_type` type is responsible for moving through the list, retrieving and displaying data.
- When acquiring data, there is a method `get_alloc` to allocate memory separate from the list elements, and a method ` get_ptr` to get a pointer that points directly inside the list.

### Append and retrieve data

```fortran
program append_and_retrieve
    use flinkedlist
    use iso_fortran_env
    implicit none
    
    type user_type
      integer :: i = 1
      real(kind=real32) :: x =1.6
    end type
    
    type(user_type) :: ud
    type(list_type) :: list
    type(node_operator_type) node
    class(*), allocatable :: val
    class(*), pointer :: val_ptr
    integer :: i
    
    !... append data into the list ...
    call list%append(1_int32) !append element(int32) in the *samplelist*
    call list%append(32.0_real32)    !append element(real64) in the *samplelist*
    call list%append(64.0_real64)    !append element(real64) in the *samplelist*
    call list%append(128.0_real128)    !append element(real128) in the *samplelist*
    call list%append((3.0_real32,2.0_real32))    !append element(complex32) in the *samplelist*
    call list%append((6.0_real64,4.0_real64))    !append element(complex64) in the *samplelist*
    call list%append(.TRUE.) !append element(logical) in the *samplelist*
    call list%append("a")    !append element(character) in the *samplelist*
    call list%append("Hello Fortran Linked list!")    !append element(strings) in the *samplelist*
    call list%append(ud) !append element(user defined type) in the *samplelist*
    !... show list data
    print *, "!-- show all (intrinsinc data type only)"
    call list%showall()  !show all elements in the *samplelist*
    print *, "!-- show all (add user defined type showing routine)"
    call list%showall(showproc=user_show_proc) !show all elements in the *samplelist*

    !... retrieve data from the list
    call node%init(list)
    call node%head()
    do i=1,4
      call node%next()
    end do
    call node%get_alloc(val) !copy list element to new memory
    call node%get_ptr(val_ptr) !pointer which points inside the list

    !... showing data from a list
    call obj_show(val)
    call obj_show(val_ptr)
    contains
      subroutine user_show_proc(obj, passdata, fid)
        class(*), intent(in) :: obj
        class(*), intent(in),optional :: passdata
        integer, intent(in), optional :: fid
        select type(obj)
        type is (user_type)
          print *, "user_typee:", obj
        end select
      end subroutine
end program
```

### Apply procedure to each data

### Deep copy of list_type

### Node operation

### Sort data

### Transform (list -> array)
